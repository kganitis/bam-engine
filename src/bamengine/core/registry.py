"""Registry system for roles and events."""

from __future__ import annotations

from typing import TYPE_CHECKING, Callable, TypeVar

if TYPE_CHECKING:
    from bamengine.core.event import Event
    from bamengine.core.role import Role

# Type variables for generic decorator typing
R = TypeVar("R", bound="Role")
E = TypeVar("E", bound="Event")

# Global registry storage
_ROLE_REGISTRY: dict[str, type[Role]] = {}
_EVENT_REGISTRY: dict[str, type[Event]] = {}


def role(name: str | None = None) -> Callable[[type[R]], type[R]]:
    """
    Decorator to register a role class in the global registry.

    Roles can be registered with an explicit name or use the class name.
    Last registration wins, enabling user substitution.

    Parameters
    ----------
    name : str or None, optional
        Name to register under. If None, uses the class name.

    Returns
    -------
    Callable
        Decorator function that registers the role and returns the class.

    Examples
    --------
    >>> from bamengine.typing import Float1D
    >>>
    >>> @role("Producer")
    >>> class Producer(Role):
    ...     price: Float1D
    ...     production: Float1D

    >>> # Alternative: use class name
    >>> @role()
    >>> class Producer(Role):
    ...     ...  # Registered as "Producer"

    >>> # User substitution (last registration wins)
    >>> @role("Producer")
    >>> class CustomProducer(Role):
    ...     ...  # Replaces built-in Producer
    """

    def decorator(role_cls: type[R]) -> type[R]:
        role_name = name or role_cls.__name__
        _ROLE_REGISTRY[role_name] = role_cls

        # Store name on class for introspection
        role_cls._role_name = role_name

        return role_cls

    return decorator


def event(name: str | None = None) -> Callable[[type[E]], type[E]]:
    """
    Decorator to register an event class in the global registry.

    Events can be registered with an explicit name or use the auto-generated
    snake_case name from the class name. Last registration wins, enabling
    user substitution.

    Parameters
    ----------
    name : str or None, optional
        Name to register under. If None, uses the event's auto-generated
        `name` attribute (CamelCase -> snake_case).

    Returns
    -------
    Callable
        Decorator function that registers the event and returns the class.

    Examples
    --------
    >>> @event("firms_decide_price")
    >>> class FirmsDecidePrice(Event):
    ...     def execute(self, sim):
    ...         ...

    >>> # Alternative: use auto-generated name
    >>> @event()
    >>> class FirmsDecidePrice(Event):
    ...     # Auto-generates name = "firms_decide_price"
    ...     def execute(self, sim):
    ...         ...

    >>> # User substitution
    >>> @event("firms_decide_price")
    >>> class CustomPricingRule(Event):  # Replaces built-in event
    ...     def execute(self, sim) -> None :
    ...         ...
    """

    def decorator(event_cls: type[E]) -> type[E]:
        # Use provided name or read from class attribute
        # (auto-generated by __init_subclass__)
        event_name = name or event_cls.name
        _EVENT_REGISTRY[event_name] = event_cls

        return event_cls

    return decorator


def get_role(name: str) -> type[Role]:
    """
    Retrieve a role class from the registry by name.

    Parameters
    ----------
    name : str
        Name of the role to retrieve.

    Returns
    -------
    type[Role]
        The registered role class.

    Raises
    ------
    KeyError
        If the role name is not found in the registry.

    Examples
    --------
    >>> import numpy as np
    >>>
    >>> producer_cls = get_role("Producer")
    >>> producer_instance = producer_cls(
    ...     price=np.ones(10),
    ...     production=np.ones(10),
    ...     inventory=np.zeros(10),
    ... )
    """
    if name not in _ROLE_REGISTRY:
        available = ", ".join(sorted(_ROLE_REGISTRY.keys()))
        raise KeyError(
            f"Role '{name}' not found in registry. " f"Available roles: {available}"
        )
    return _ROLE_REGISTRY[name]


def get_event(name: str) -> type[Event]:
    """
    Retrieve an event class from the registry by name.

    Parameters
    ----------
    name : str
        Name of the event to retrieve.

    Returns
    -------
    type[Event]
        The registered event class.

    Raises
    ------
    KeyError
        If the event name is not found in the registry.

    Examples
    --------
    >>> from bamengine.simulation import Simulation
    >>> sim = Simulation()
    >>> event_cls = get_event("firms_decide_price")
    >>> event_instance = event_cls()
    >>> event_instance.execute(sim)
    """
    if name not in _EVENT_REGISTRY:
        available = ", ".join(sorted(_EVENT_REGISTRY.keys()))
        raise KeyError(
            f"Event '{name}' not found in registry. " f"Available events: {available}"
        )
    return _EVENT_REGISTRY[name]


def list_roles() -> list[str]:
    """Return sorted list of all registered role names."""
    return sorted(_ROLE_REGISTRY.keys())


def list_events() -> list[str]:
    """Return sorted list of all registered event names."""
    return sorted(_EVENT_REGISTRY.keys())


def clear_registry() -> None:
    """
    Clear all registrations (useful for testing).

    WARNING: This is a destructive operation. Only use in test teardown.
    """
    _ROLE_REGISTRY.clear()
    _EVENT_REGISTRY.clear()
